<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>constriction.stream.queue API documentation</title>
<meta name="description" content="Range Coding: a stream code with queue semantics (i.e., &#34;first in first out&#34;) [1, 2] â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>constriction.stream.queue</code></h1>
</header>
<section id="section-intro">
<p>Range Coding: a stream code with queue semantics (i.e., "first in first out") [1, 2].</p>
<p>The Range Coding algorithm is a variation on Arithmetic Coding [1, 3] that runs more efficiently
on standard computing hardware.</p>
<h2 id="example">Example</h2>
<p>The following example shows a full round trip that encodes a message, prints its compressed
representation, and then decodes the message again. The message is a sequence of 11 integers
(referred to as "symbols") and comprised of two parts: the first 7 symbols are encoded with an
i.i.d. entropy model, i.e., using the same distribution for each symbol, which happens to be a
<a href="model.html#constriction.stream.model.Categorical"><code>Categorical</code></a> distribution; and the remaining
4 symbols are each encoded with a different entropy model, but all of these 4 models are from
the same family of <a href="model.html#constriction.stream.model.QuantizedGaussian"><code>QuantizedGaussian</code></a>s,
just with different model parameters (means and standard deviations) for each of the 4 symbols.</p>
<pre><code class="language-python">import constriction
import numpy as np

# Define the two parts of the message and their respective entropy models:
message_part1       = np.array([1, 2, 0, 3, 2, 3, 0], dtype=np.int32)
probabilities_part1 = np.array([0.2, 0.4, 0.1, 0.3], dtype=np.float32)
model_part1       = constriction.stream.model.Categorical(probabilities_part1, perfect=False)
# `model_part1` is a categorical distribution over the (implied) alphabet
# {0,1,2,3} with P(X=0) = 0.2, P(X=1) = 0.4, P(X=2) = 0.1, and P(X=3) = 0.3;
# we will use it below to encode each of the 7 symbols in `message_part1`.

message_part2       = np.array([6,   10,   -4,    2  ], dtype=np.int32)
means_part2         = np.array([2.5, 13.1, -1.1, -3.0], dtype=np.float32)
stds_part2          = np.array([4.1,  8.7,  6.2,  5.4], dtype=np.float32)
model_family_part2  = constriction.stream.model.QuantizedGaussian(-100, 100)
# `model_family_part2` is a *family* of Gaussian distributions, quantized to
# bins of width 1 centered at the integers -100, -99, ..., 100. We could
# have provided a fixed mean and standard deviation to the constructor of
# `QuantizedGaussian` but we'll instead provide individual means and standard
# deviations for each symbol when we encode and decode `message_part2` below.

print(f&quot;Original message: {np.concatenate([message_part1, message_part2])}&quot;)

# Encode both parts of the message in sequence:
encoder = constriction.stream.queue.RangeEncoder()
encoder.encode(message_part1, model_part1)
encoder.encode(message_part2, model_family_part2, means_part2, stds_part2)

# Get and print the compressed representation:
compressed = encoder.get_compressed()
print(f&quot;compressed representation: {compressed}&quot;)
print(f&quot;(in binary: {[bin(word) for word in compressed]})&quot;)

# You could save `compressed` to a file using `compressed.tofile(&quot;filename&quot;)`
# and read it back in: `compressed = np.fromfile(&quot;filename&quot;, dtype=np.uint32).

# Decode the message:
decoder = constriction.stream.queue.RangeDecoder(compressed)
decoded_part1 = decoder.decode(model_part1, 7) # (decodes 7 symbols)
decoded_part2 = decoder.decode(model_family_part2, means_part2, stds_part2)
print(f&quot;Decoded message: {np.concatenate([decoded_part1, decoded_part2])}&quot;)
assert np.all(decoded_part1 == message_part1)
assert np.all(decoded_part2 == message_part2)
</code></pre>
<h2 id="references">References</h2>
<p>[1] Pasco, Richard Clark. Source coding algorithms for fast data compression. Diss.
Stanford University, 1976.</p>
<p>[2] Martin, G. Nigel N. "Range encoding: an algorithm for removing redundancy from a
digitised message." Proc. Institution of Electronic and Radio Engineers International
Conference on Video and Data Recording. 1979.</p>
<p>[3] Rissanen, Jorma, and Glen G. Langdon. "Arithmetic coding." IBM Journal of research
and development 23.2 (1979): 149-162.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="constriction.stream.queue.RangeDecoder"><code class="flex name class">
<span>class <span class="ident">RangeDecoder</span></span>
<span>(</span><span>compressed)</span>
</code></dt>
<dd>
<div class="desc"><p>A decoder of data that was previously encoded with a <code><a title="constriction.stream.queue.RangeEncoder" href="#constriction.stream.queue.RangeEncoder">RangeEncoder</a></code>.</p>
<p>The constructor expects a single argument <code>compressed</code>, which has to be a rank-1 numpy array
with <code>dtype=np.uint32</code> that contains the compressed data (as returned by the method
<a href="#constriction.stream.queue.RangeEncoder.get_compressed"><code>get_compressed</code></a> of a <code><a title="constriction.stream.queue.RangeEncoder" href="#constriction.stream.queue.RangeEncoder">RangeEncoder</a></code>).
The provided compressed data gets <em>copied</em> into an internal buffer of the <code><a title="constriction.stream.queue.RangeDecoder" href="#constriction.stream.queue.RangeDecoder">RangeDecoder</a></code>.</p>
<p>To decode data with a <code><a title="constriction.stream.queue.RangeDecoder" href="#constriction.stream.queue.RangeDecoder">RangeDecoder</a></code>, call its method
<a href="#constriction.stream.queue.RangeDecoder.decode"><code>decode</code></a> one or more times. Each decoding
operation consumes some portion of the compressed data from the <code><a title="constriction.stream.queue.RangeDecoder" href="#constriction.stream.queue.RangeDecoder">RangeDecoder</a></code>'s internal
buffer.</p>
<h2 id="example">Example</h2>
<p>See <a href="#example">module level example</a>.</p></div>
<h3>Methods</h3>
<dl>
<dt id="constriction.stream.queue.RangeDecoder.clone"><code class="name flex">
<span>def <span class="ident">clone</span></span>(<span>self, /)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a deep copy of the coder and returns it.</p>
<p>The returned copy will initially encapsulate the identical compressed data as the
original coder, but the two coders can be used independently without influencing
other.</p></div>
</dd>
<dt id="constriction.stream.queue.RangeDecoder.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self, /, model, *optional_amt_or_model_params)</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes one or more symbols, consuming them from the encapsulated compressed data.</p>
<p>This method can be called in 3 different ways:</p>
<h2 id="option-1-decodemodel">Option 1: decode(model)</h2>
<p>Decodes a <em>single</em> symbol with a concrete (i.e., fully parameterized) entropy model and
returns the decoded symbol; (for optimal computational efficiency, don't use this option in
a loop if you can instead use one of the two alternative options below.)</p>
<p>For example:</p>
<pre><code class="language-python"># Define a concrete categorical entropy model over the (implied)
# alphabet {0, 1, 2}:
probabilities = np.array([0.1, 0.6, 0.3], dtype=np.float32)
model = constriction.stream.model.Categorical(probabilities, perfect=False)

# Decode a single symbol from some example compressed data:
compressed = np.array([3089773345, 1894195597], dtype=np.uint32)
decoder = constriction.stream.queue.RangeDecoder(compressed)
symbol = decoder.decode(model)
print(symbol) # (prints: 2)
# ... then decode some more symbols ...
</code></pre>
<h2 id="option-2-decodemodel-amt-where-amt-is-an-integer">Option 2: decode(model, amt) [where <code>amt</code> is an integer]</h2>
<p>Decodes <code>amt</code> i.i.d. symbols using the same concrete (i.e., fully parametrized) entropy
model for each symbol, and returns the decoded symbols as a rank-1 numpy array with
<code>dtype=np.int32</code> and length <code>amt</code>;</p>
<p>For example:</p>
<pre><code class="language-python"># Use the same concrete entropy model as in the previous example:
probabilities = np.array([0.1, 0.6, 0.3], dtype=np.float32)
model = constriction.stream.model.Categorical(probabilities, perfect=False)

# Decode 9 symbols from some example compressed data, using the
# same (fixed) entropy model defined above for all symbols:
compressed = np.array([369323598], dtype=np.uint32)
decoder = constriction.stream.queue.RangeDecoder(compressed)
symbols = decoder.decode(model, 9)
print(symbols) # (prints: [0, 2, 1, 2, 0, 2, 0, 2, 1])
</code></pre>
<h2 id="option-3-decodemodel_family-params1-params2">Option 3: decode(model_family, params1, params2, &hellip;)</h2>
<p>Decodes multiple symbols, using the same <em>family</em> of entropy models (e.g., categorical or
quantized Gaussian) for all symbols, but with different model parameters for each symbol,
and returns the decoded symbols as a rank-1 numpy array with <code>dtype=np.int32</code>; here, all
<code>paramsX</code> arguments are arrays of equal length (the number of symbols to be decoded). The
number of required <code>paramsX</code> arguments and their shapes and <code>dtype</code>s depend on the model
family.</p>
<p>For example, the
<a href="model.html#constriction.stream.model.QuantizedGaussian"><code>QuantizedGaussian</code></a> model family
expects two rank-1 model parameters with a float <code>dtype</code>, which specify the mean and
standard deviation for each entropy model:</p>
<pre><code class="language-python"># Define a generic quantized Gaussian distribution for all integers
# in the range from -100 to 100 (both ends inclusive):
model_family = constriction.stream.model.QuantizedGaussian(-100, 100)

# Specify the model parameters for each symbol:
means = np.array([10.3, -4.7, 20.5], dtype=np.float32)
stds  = np.array([ 5.2, 24.2,  3.1], dtype=np.float32)

# Decode a message from some example compressed data:
compressed = np.array([2655472005], dtype=np.uint32)
decoder = constriction.stream.queue.RangeDecoder(compressed)
symbols = decoder.decode(model_family, means, stds)
print(symbols) # (prints: [12, -13, 25])
</code></pre>
<p>By contrast, the <a href="model.html#constriction.stream.model.Categorical"><code>Categorical</code></a> model
family expects a single rank-2 model parameter where the i'th row lists the
probabilities for each possible value of the i'th symbol:</p>
<pre><code class="language-python"># Define 2 categorical models over the alphabet {0, 1, 2, 3, 4}:
probabilities = np.array(
    [[0.1, 0.2, 0.3, 0.1, 0.3],  # (for first decoded symbol)
     [0.3, 0.2, 0.2, 0.2, 0.1]], # (for second decoded symbol)
    dtype=np.float32)
model_family = constriction.stream.model.Categorical(perfect=False)

# Decode 2 symbols:
compressed = np.array([2705829535], dtype=np.uint32)
decoder = constriction.stream.queue.RangeDecoder(compressed)
symbols = decoder.decode(model_family, probabilities)
print(symbols) # (prints: [3, 1])
</code></pre></div>
</dd>
<dt id="constriction.stream.queue.RangeDecoder.maybe_exhausted"><code class="name flex">
<span>def <span class="ident">maybe_exhausted</span></span>(<span>self, /)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns <code>True</code> if all compressed data <em>may</em> have already been decoded and <code>False</code> if there
is definitely still some more data available to decode.</p>
<p>A return value of <code>True</code> does not necessarily mean that there is no data left on the
decoder because <code><a title="constriction" href="../index.html">constriction</a></code>'s range coding implementation&ndash;by design&ndash;cannot detect end-
of-stream in all cases. If you need ot be able to decode variable-length messages then you
can introduce an "end of stream" sentinel symbol, which you append to all messages before
encoding them.</p></div>
</dd>
<dt id="constriction.stream.queue.RangeDecoder.seek"><code class="name flex">
<span>def <span class="ident">seek</span></span>(<span>self, /, position, state)</span>
</code></dt>
<dd>
<div class="desc"><p>Jumps to a checkpoint recorded with method
<a href="#constriction.stream.queue.RangeEncoder.pos"><code>pos</code></a> during encoding.</p>
<p>This allows random-access decoding. The arguments <code>position</code> and <code>state</code> are the two values
returned by the <code><a title="constriction.stream.queue.RangeEncoder" href="#constriction.stream.queue.RangeEncoder">RangeEncoder</a></code>'s method <a href="#constriction.stream.queue.RangeEncoder.pos"><code>pos</code></a>.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python">probabilities = np.array([0.2, 0.4, 0.1, 0.3], dtype=np.float32)
model         = constriction.stream.model.Categorical(probabilities, perfect=False)
message_part1 = np.array([1, 2, 0, 3, 2, 3, 0], dtype=np.int32)
message_part2 = np.array([2, 2, 0, 1, 3], dtype=np.int32)

# Encode both parts of the message and record a checkpoint in-between:
encoder = constriction.stream.queue.RangeEncoder()
encoder.encode(message_part1, model)
(position, state) = encoder.pos() # Records a checkpoint.
encoder.encode(message_part2, model)

compressed = encoder.get_compressed()
decoder = constriction.stream.queue.RangeDecoder(compressed)

# Decode first symbol:
print(decoder.decode(model)) # (prints: 1)

# Jump to part 2 and decode it:
decoder.seek(position, state)
decoded_part2 = decoder.decode(model, 5)
assert np.all(decoded_part2 == message_part2)
</code></pre></div>
</dd>
</dl>
</dd>
<dt id="constriction.stream.queue.RangeEncoder"><code class="flex name class">
<span>class <span class="ident">RangeEncoder</span></span>
</code></dt>
<dd>
<div class="desc"><p>An encoder that uses the range coding algorithm.</p>
<p>To encode data with a <code><a title="constriction.stream.queue.RangeEncoder" href="#constriction.stream.queue.RangeEncoder">RangeEncoder</a></code>, call its method
<a href="#constriction.stream.queue.RangeEncoder.encode"><code>encode</code></a> one or more times. A <code><a title="constriction.stream.queue.RangeEncoder" href="#constriction.stream.queue.RangeEncoder">RangeEncoder</a></code>
has an internal buffer of compressed data, and each <code>encode</code> operation appends to this internal
buffer. You can copy out the contents of the internal buffer by calling the method
<a href="#constriction.stream.queue.RangeEncoder.get_compressed"><code>get_compressed</code></a>. This will return a
rank-1 numpy array with <code>dtype=np.uint32</code> that you can pass to the constructor of a
<code><a title="constriction.stream.queue.RangeDecoder" href="#constriction.stream.queue.RangeDecoder">RangeDecoder</a></code> or write to a file for decoding at some later time (see example in the
documentation of the method
<a href="#constriction.stream.queue.RangeEncoder.get_compressed"><code>get_compressed</code></a>).</p>
<h2 id="example">Example</h2>
<p>See <a href="#example">module level example</a>.</p></div>
<h3>Methods</h3>
<dl>
<dt id="constriction.stream.queue.RangeEncoder.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self, /)</span>
</code></dt>
<dd>
<div class="desc"><p>Resets the encoder to an empty state.</p>
<p>This removes any existing compressed data on the coder. It is equivalent to replacing the
coder with a new one but slightly more efficient.</p></div>
</dd>
<dt id="constriction.stream.queue.RangeEncoder.clone"><code class="name flex">
<span>def <span class="ident">clone</span></span>(<span>self, /)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a deep copy of the coder and returns it.</p>
<p>The returned copy will initially encapsulate the identical compressed data as the
original coder, but the two coders can be used independently without influencing
other.</p></div>
</dd>
<dt id="constriction.stream.queue.RangeEncoder.encode"><code class="name flex">
<span>def <span class="ident">encode</span></span>(<span>self, /, symbols, model, *optional_model_params)</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes one or more symbols, appending them to the encapsulated compressed data.</p>
<p>This method can be called in 3 different ways:</p>
<h2 id="option-1-encodesymbol-model">Option 1: encode(symbol, model)</h2>
<p>Encodes a <em>single</em> symbol with a concrete (i.e., fully parameterized) entropy model; (for
optimal computational efficiency, don't use this option in a loop if you can instead use one
of the two alternative options below.)</p>
<p>For example:</p>
<pre><code class="language-python"># Define a concrete categorical entropy model over the (implied)
# alphabet {0, 1, 2}:
probabilities = np.array([0.1, 0.6, 0.3], dtype=np.float32)
model = constriction.stream.model.Categorical(probabilities, perfect=False)

# Encode a single symbol with this entropy model:
encoder = constriction.stream.queue.RangeEncoder()
encoder.encode(2, model) # Encodes the symbol `2`.
# ... then encode some more symbols ...
</code></pre>
<h2 id="option-2-encodesymbols-model">Option 2: encode(symbols, model)</h2>
<p>Encodes multiple i.i.d. symbols, i.e., all symbols in the rank-1 array <code>symbols</code> will be
encoded with the same concrete (i.e., fully parameterized) entropy model.</p>
<p>For example:</p>
<pre><code class="language-python"># Use the same concrete entropy model as in the previous example:
probabilities = np.array([0.1, 0.6, 0.3], dtype=np.float32)
model = constriction.stream.model.Categorical(probabilities, perfect=False)

# Encode an example message using the above `model` for all symbols:
symbols = np.array([0, 2, 1, 2, 0, 2, 0, 2, 1], dtype=np.int32)
encoder = constriction.stream.queue.RangeEncoder()
encoder.encode(symbols, model)
print(encoder.get_compressed()) # (prints: [369323576])
</code></pre>
<h2 id="option-3-encodesymbols-model_family-params1-params2">Option 3: encode(symbols, model_family, params1, params2, &hellip;)</h2>
<p>Encodes multiple symbols, using the same <em>family</em> of entropy models (e.g., categorical or
quantized Gaussian) for all symbols, but with different model parameters for each symbol;
here, each <code>paramsX</code> argument is an array of the same length as <code>symbols</code>. The number of
required <code>paramsX</code> arguments and their shapes and <code>dtype</code>s depend on the model family.</p>
<p>For example, the
<a href="model.html#constriction.stream.model.QuantizedGaussian"><code>QuantizedGaussian</code></a> model family
expects two rank-1 model parameters with float <code>dtype</code>, which specify the mean and
standard deviation for each entropy model:</p>
<pre><code class="language-python"># Define a generic quantized Gaussian distribution for all integers
# in the range from -100 to 100 (both ends inclusive):
model_family = constriction.stream.model.QuantizedGaussian(-100, 100)

# Specify the model parameters for each symbol:
means = np.array([10.3, -4.7, 20.5], dtype=np.float32)
stds  = np.array([ 5.2, 24.2,  3.1], dtype=np.float32)

# Encode an example message:
# (needs `len(symbols) == len(means) == len(stds)`)
symbols = np.array([12, -13, 25], dtype=np.int32)
encoder = constriction.stream.queue.RangeEncoder()
encoder.encode(symbols, model_family, means, stds)
print(encoder.get_compressed()) # (prints: [2655472005])
</code></pre>
<p>By contrast, the <a href="model.html#constriction.stream.model.Categorical"><code>Categorical</code></a> model
family expects a single rank-2 model parameter where the i'th row lists the
probabilities for each possible value of the i'th symbol:</p>
<pre><code class="language-python"># Define 2 categorical models over the alphabet {0, 1, 2, 3, 4}:
probabilities = np.array(
    [[0.1, 0.2, 0.3, 0.1, 0.3],  # (for first encoded symbol)
     [0.3, 0.2, 0.2, 0.2, 0.1]], # (for second encoded symbol)
    dtype=np.float32)
model_family = constriction.stream.model.Categorical(perfect=False)

# Encode 2 symbols (needs `len(symbols) == probabilities.shape[0]`):
symbols = np.array([3, 1], dtype=np.int32)
encoder = constriction.stream.queue.RangeEncoder()
encoder.encode(symbols, model_family, probabilities)
print(encoder.get_compressed()) # (prints: [2705829510])
</code></pre></div>
</dd>
<dt id="constriction.stream.queue.RangeEncoder.get_compressed"><code class="name flex">
<span>def <span class="ident">get_compressed</span></span>(<span>self, /)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of the compressed data accumulated so far, as a rank-1 numpy array of
<code>dtype=np.uint32</code>.</p>
<p>You will typically only want to call this method at the very end of your encoding task,
i.e., once you've encoded the <em>entire</em> message. There is usually no need to call this method
after encoding each symbol or other portion of your message. The encoders in <code><a title="constriction" href="../index.html">constriction</a></code>
<em>accumulate</em> compressed data in an internal buffer, and encoding (semantically) <em>appends</em> to
this buffer.</p>
<p>That said, calling <code>get_compressed</code> has no side effects, so you <em>can</em> call <code>get_compressed</code>,
then continue to encode more symbols, and then call <code>get_compressed</code> again. The first call
of <code>get_compressed</code> will have no effect on the return value of the second call of
<code>get_compressed</code>.</p>
<p>The return value is a rank-1 numpy array of <code>dtype=np.uint32</code>. You can write it to a file by
calling <code>to_file</code> on it, but we recommend to convert it into an architecture-independent
byte order first:</p>
<pre><code class="language-python">import sys

encoder = constriction.stream.queue.RangeEncoder()
# ... encode some message (skipped here) ...
compressed = encoder.get_compressed() # returns a numpy array.
if sys.byteorder != 'little':
    # Let's save data in little-endian byte order by convention.
    compressed.byteswap(inplace=True)
compressed.tofile('compressed-file.bin')

# At a later point, you might want to read and decode the file:
compressed = np.fromfile('compressed-file.bin', dtype=np.uint32)
if sys.byteorder != 'little':
    # Restore native byte order before passing it to `constriction`.
    compressed.byteswap(inplace=True)
decoder = constriction.stream.queue.RangeDecoder(compressed)
# ... decode the message (skipped here) ...
</code></pre></div>
</dd>
<dt id="constriction.stream.queue.RangeEncoder.get_decoder"><code class="name flex">
<span>def <span class="ident">get_decoder</span></span>(<span>self, /)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a <code><a title="constriction.stream.queue.RangeDecoder" href="#constriction.stream.queue.RangeDecoder">RangeDecoder</a></code> that is initialized with a copy of the compressed data currently on
this <code><a title="constriction.stream.queue.RangeEncoder" href="#constriction.stream.queue.RangeEncoder">RangeEncoder</a></code>.</p>
<p>If <code>encoder</code> is a <code><a title="constriction.stream.queue.RangeEncoder" href="#constriction.stream.queue.RangeEncoder">RangeEncoder</a></code>, then</p>
<pre><code class="language-python">decoder = encoder.get_decoder()
</code></pre>
<p>is equivalent to:</p>
<pre><code class="language-python">compressed = encoder.get_compressed()
decoder = constriction.stream.stack.RangeDecoder(compressed)
</code></pre>
<p>Calling <code>get_decoder</code> is more efficient since it copies the compressed data only once
whereas the longhand version copies the data twice.</p></div>
</dd>
<dt id="constriction.stream.queue.RangeEncoder.is_empty"><code class="name flex">
<span>def <span class="ident">is_empty</span></span>(<span>self, /)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns <code>True</code> iff the coder is in its default initial state.</p>
<p>The default initial state is the state returned by the constructor when
called without arguments, or the state to which the coder is set when
calling <code>clear</code>.</p></div>
</dd>
<dt id="constriction.stream.queue.RangeEncoder.num_bits"><code class="name flex">
<span>def <span class="ident">num_bits</span></span>(<span>self, /)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current size of the compressed data, in bits, rounded up to full words.</p>
<p>This is 32 times the result of what <a href="#constriction.stream.queue.RangeEncoder.num_words"><code>num_words</code></a>
would return.</p></div>
</dd>
<dt id="constriction.stream.queue.RangeEncoder.num_words"><code class="name flex">
<span>def <span class="ident">num_words</span></span>(<span>self, /)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current size of the encapsulated compressed data, in <code>np.uint32</code> words.</p>
<p>Thus, the number returned by this method is the length of the array that you would get if
you called <a href="#constriction.stream.queue.RangeEncoder.get_compressed"><code>get_compressed</code></a>.</p></div>
</dd>
<dt id="constriction.stream.queue.RangeEncoder.pos"><code class="name flex">
<span>def <span class="ident">pos</span></span>(<span>self, /)</span>
</code></dt>
<dd>
<div class="desc"><p>Records a checkpoint to which you can jump during decoding using
<a href="#constriction.stream.queue.RangeDecoder.seek"><code>seek</code></a>.</p>
<p>Returns a tuple <code>(position, state)</code> where <code>position</code> is an integer that specifies how many
32-bit words of compressed data have been produced so far, and <code>state</code> is a tuple of two
integers that define the <code><a title="constriction.stream.queue.RangeEncoder" href="#constriction.stream.queue.RangeEncoder">RangeEncoder</a></code>'s internal state (so that it can be restored upon
<a href="#constriction.stream.queue.RangeDecoder.seek"><code>seek</code>ing</a>.</p>
<p><strong>Note:</strong> Don't call <code>pos</code> if you just want to find out how much compressed data has been
produced so far. Call <a href="#constriction.stream.queue.RangeEncoder.num_words"><code>num_words</code></a>
instead.</p>
<h2 id="example">Example</h2>
<p>See <a href="#constriction.stream.queue.RangeDecoder.seek"><code>seek</code></a>.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul>
<li><a href="#example">Example</a></li>
<li><a href="#references">References</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="constriction.stream" href="../stream.html">constriction.stream</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="constriction.stream.queue.RangeDecoder" href="#constriction.stream.queue.RangeDecoder">RangeDecoder</a></code></h4>
<ul class="">
<li><code><a title="constriction.stream.queue.RangeDecoder.clone" href="#constriction.stream.queue.RangeDecoder.clone">clone</a></code></li>
<li><code><a title="constriction.stream.queue.RangeDecoder.decode" href="#constriction.stream.queue.RangeDecoder.decode">decode</a></code></li>
<li><code><a title="constriction.stream.queue.RangeDecoder.maybe_exhausted" href="#constriction.stream.queue.RangeDecoder.maybe_exhausted">maybe_exhausted</a></code></li>
<li><code><a title="constriction.stream.queue.RangeDecoder.seek" href="#constriction.stream.queue.RangeDecoder.seek">seek</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="constriction.stream.queue.RangeEncoder" href="#constriction.stream.queue.RangeEncoder">RangeEncoder</a></code></h4>
<ul class="two-column">
<li><code><a title="constriction.stream.queue.RangeEncoder.clear" href="#constriction.stream.queue.RangeEncoder.clear">clear</a></code></li>
<li><code><a title="constriction.stream.queue.RangeEncoder.clone" href="#constriction.stream.queue.RangeEncoder.clone">clone</a></code></li>
<li><code><a title="constriction.stream.queue.RangeEncoder.encode" href="#constriction.stream.queue.RangeEncoder.encode">encode</a></code></li>
<li><code><a title="constriction.stream.queue.RangeEncoder.get_compressed" href="#constriction.stream.queue.RangeEncoder.get_compressed">get_compressed</a></code></li>
<li><code><a title="constriction.stream.queue.RangeEncoder.get_decoder" href="#constriction.stream.queue.RangeEncoder.get_decoder">get_decoder</a></code></li>
<li><code><a title="constriction.stream.queue.RangeEncoder.is_empty" href="#constriction.stream.queue.RangeEncoder.is_empty">is_empty</a></code></li>
<li><code><a title="constriction.stream.queue.RangeEncoder.num_bits" href="#constriction.stream.queue.RangeEncoder.num_bits">num_bits</a></code></li>
<li><code><a title="constriction.stream.queue.RangeEncoder.num_words" href="#constriction.stream.queue.RangeEncoder.num_words">num_words</a></code></li>
<li><code><a title="constriction.stream.queue.RangeEncoder.pos" href="#constriction.stream.queue.RangeEncoder.pos">pos</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
