<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>constriction.stream.stack API documentation</title>
<meta name="description" content="Asymmetric Numeral Systems (ANS): a stream code with stack semantics
(i.e., &#34;last in first out&#34;) [1] â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>constriction.stream.stack</code></h1>
</header>
<section id="section-intro">
<p>Asymmetric Numeral Systems (ANS): a stream code with stack semantics
(i.e., "last in first out") [1].</p>
<p>The ANS entropy coding algorithm is a popular choice for bits-back coding with latent variable
models. It uses only a single data structure, <code><a title="constriction.stream.stack.AnsCoder" href="#constriction.stream.stack.AnsCoder">AnsCoder</a></code>, which operates as both encoder and
decoder. This allows you to easily switch back and forth between encoding and decoding
operations. A further, more subtle property that distinguishes <code>constrictions</code> ANS
implementation from its Range Coding implementation in the sister module <code><a title="constriction.stream.queue" href="queue.html">constriction.stream.queue</a></code>) is that
encoding with an <code><a title="constriction.stream.stack.AnsCoder" href="#constriction.stream.stack.AnsCoder">AnsCoder</a></code> is <em>surjective</em> and therefore decoding is injective. This means that
you can decode some symbols from any bitstring, regardless of its origin, and then re-encode the
symbols to exactly reconstruct the original bitstring (e.g., for bits-back coding).</p>
<h2 id="stack-semantics">Stack Semantics</h2>
<p>ANS operates as a <em>stack</em>: encoding <em>pushes</em> (i.e., appends) data onto the top of the stack and
decoding <em>pops</em>
data from the top of the stack (i.e., it consumes data from the <em>same</em> end).
This means that encoding and
decoding operate in opposite directions to each other. When using
an <code><a title="constriction.stream.stack.AnsCoder" href="#constriction.stream.stack.AnsCoder">AnsCoder</a></code>, we recommend to encode sequences of symbols in reverse order so that you can
later decode them in their original order. The method <code>encode_reverse</code> does this automatically
when given an array of symbols. If you call <code>encode_reverse</code> several times to encode several
parts of a message, then start with the last part of your message and work your way back, as in
the example below.</p>
<h2 id="example">Example</h2>
<p>The following example shows a full round trip that encodes a message, prints its compressed
representation, and then decodes the message again. The message is a sequence of 11 integers
(referred to as "symbols") and comprised of two parts: the first 7 symbols are encoded with an
i.i.d. entropy model, i.e., using the same distribution for each symbol, which happens to be a
<a href="model.html#constriction.stream.model.Categorical"><code>Categorical</code></a> distribution; and the remaining
4 symbols are each encoded with a different entropy model, but all of these 4 models are from
the same family of <a href="model.html#constriction.stream.model.QuantizedGaussian"><code>QuantizedGaussian</code></a>s,
just with different model parameters (means and standard deviations) for each of the 4 symbols.</p>
<p>Notice that we encode part 2 before part 1, but when we decode, we first obtain part 1 and then
part 2. This is because of the <code><a title="constriction.stream.stack.AnsCoder" href="#constriction.stream.stack.AnsCoder">AnsCoder</a></code>'s <a href="#stack-semantics">stack semantics</a>.</p>
<pre><code class="language-python">import constriction
import numpy as np

# Define the two parts of the message and their respective entropy models:
message_part1       = np.array([1, 2, 0, 3, 2, 3, 0], dtype=np.int32)
probabilities_part1 = np.array([0.2, 0.4, 0.1, 0.3], dtype=np.float32)
model_part1       = constriction.stream.model.Categorical(probabilities_part1, perfect=False)
# `model_part1` is a categorical distribution over the (implied) alphabet
# {0,1,2,3} with P(X=0) = 0.2, P(X=1) = 0.4, P(X=2) = 0.1, and P(X=3) = 0.3;
# we will use it below to encode each of the 7 symbols in `message_part1`.

message_part2       = np.array([6,   10,   -4,    2  ], dtype=np.int32)
means_part2         = np.array([2.5, 13.1, -1.1, -3.0], dtype=np.float32)
stds_part2          = np.array([4.1,  8.7,  6.2,  5.4], dtype=np.float32)
model_family_part2  = constriction.stream.model.QuantizedGaussian(-100, 100)
# `model_family_part2` is a *family* of Gaussian distributions, quantized to
# bins of width 1 centered at the integers -100, -99, ..., 100. We could
# have provided a fixed mean and standard deviation to the constructor of
# `QuantizedGaussian` but we'll instead provide individual means and standard
# deviations for each symbol when we encode and decode `message_part2` below.

print(f&quot;Original message: {np.concatenate([message_part1, message_part2])}&quot;)

# Encode both parts of the message in sequence (in reverse order):
coder = constriction.stream.stack.AnsCoder()
coder.encode_reverse(
    message_part2, model_family_part2, means_part2, stds_part2)
coder.encode_reverse(message_part1, model_part1)

# Get and print the compressed representation:
compressed = coder.get_compressed()
print(f&quot;compressed representation: {compressed}&quot;)
print(f&quot;(in binary: {[bin(word) for word in compressed]})&quot;)

# You could save `compressed` to a file using `compressed.tofile(&quot;filename&quot;)`,
# read it back in: `compressed = np.fromfile(&quot;filename&quot;, dtype=np.uint32) and
# then re-create `coder = constriction.stream.stack.AnsCoder(compressed)`.

# Decode the message:
decoded_part1 = coder.decode(model_part1, 7) # (decodes 7 symbols)
decoded_part2 = coder.decode(model_family_part2, means_part2, stds_part2)
print(f&quot;Decoded message: {np.concatenate([decoded_part1, decoded_part2])}&quot;)
assert np.all(decoded_part1 == message_part1)
assert np.all(decoded_part2 == message_part2)
</code></pre>
<h2 id="references">References</h2>
<p>[1] Duda, Jarek, et al. "The use of asymmetric numeral systems as an accurate
replacement for Huffman coding." 2015 Picture Coding Symposium (PCS). IEEE, 2015.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="constriction.stream.stack.AnsCoder"><code class="flex name class">
<span>class <span class="ident">AnsCoder</span></span>
<span>(</span><span>compressed)</span>
</code></dt>
<dd>
<div class="desc"><p>An entropy coder based on <a href="https://en.wikipedia.org/wiki/Asymmetric_numeral_systems">Asymmetric Numeral Systems (ANS)</a> [1].</p>
<p>This is a wrapper around the Rust type [<code>constriction::stream::stack::DefaultAnsCoder</code>]
with python bindings.</p>
<p>Note that this entropy coder is a stack (a "last in first out" data
structure). You can push symbols on the stack using the method<code>encode_reverse</code>,
and then pop them off <em>in reverse order</em> using the method <code>decode</code>.</p>
<p>To copy out the compressed data that is currently on the stack, call
<code>get_compressed</code>. You would typically want write this to a binary file in some
well-documented byte order. After reading it back in at a later time, you can
decompress it by constructing an <code><a title="constriction.stream.stack.AnsCoder" href="#constriction.stream.stack.AnsCoder">AnsCoder</a></code> where you pass in the compressed
data as an argument to the constructor.</p>
<p>If you're only interested in the compressed file size, calling <code>num_bits</code> will
be cheaper as it won't actually copy out the compressed data.</p>
<h2 id="examples">Examples</h2>
<h3 id="compression">Compression:</h3>
<pre><code class="language-python">import sys
import constriction
import numpy as np

ans = constriction.stream.stack.AnsCoder()  # No args =&gt; empty ANS coder

symbols = np.array([2, -1, 0, 2, 3], dtype=np.int32)
min_supported_symbol, max_supported_symbol = -10, 10  # both inclusively
model = constriction.stream.model.QuantizedGaussian(
    min_supported_symbol, max_supported_symbol)
means = np.array([2.3, -1.7, 0.1, 2.2, -5.1], dtype=np.float32)
stds = np.array([1.1, 5.3, 3.8, 1.4, 3.9], dtype=np.float32)

ans.encode_reverse(symbols, model, means, stds)

print(f&quot;Compressed size: {ans.num_valid_bits()} bits&quot;)

compressed = ans.get_compressed()
if sys.byteorder == &quot;big&quot;:
    # Convert native byte order to a consistent one (here: little endian).
    compressed.byteswap(inplace=True)
compressed.tofile(&quot;compressed.bin&quot;)
</code></pre>
<h3 id="decompression">Decompression:</h3>
<pre><code class="language-python">import sys
import constriction
import numpy as np

compressed = np.fromfile(&quot;compressed.bin&quot;, dtype=np.uint32)
if sys.byteorder == &quot;big&quot;:
    # Convert little endian byte order to native byte order.
    compressed.byteswap(inplace=True)

ans = constriction.stream.stack.AnsCoder( compressed )
min_supported_symbol, max_supported_symbol = -10, 10  # both inclusively
model = constriction.stream.model.QuantizedGaussian(
    min_supported_symbol, max_supported_symbol)
means = np.array([2.3, -1.7, 0.1, 2.2, -5.1], dtype=np.float32)
stds = np.array([1.1, 5.3, 3.8, 1.4, 3.9], dtype=np.float32)

reconstructed = ans.decode(model, means, stds)
assert ans.is_empty()
print(reconstructed)  # Should print [2, -1, 0, 2, 3]
</code></pre>
<h2 id="constructor">Constructor</h2>
<p>Arguments:
compressed (optional) &ndash; initial compressed data, as a numpy array with
dtype <code>uint32</code>.</p>
<h2 id="references">References</h2>
<p>[1] Duda, Jarek, et al. "The use of asymmetric numeral systems as an accurate
replacement for Huffman coding." 2015 Picture Coding Symposium (PCS). IEEE, 2015.</p></div>
<h3>Methods</h3>
<dl>
<dt id="constriction.stream.stack.AnsCoder.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Resets the encoder to an empty state.</p>
<p>This removes any existing compressed data on the encoder. It is equivalent to replacing the
encoder with a new one but slightly more efficient.</p></div>
</dd>
<dt id="constriction.stream.stack.AnsCoder.clone"><code class="name flex">
<span>def <span class="ident">clone</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a deep copy of the coder and returns it.</p>
<p>The returned copy will initially encapsulate the identical compressed data as the
original coder, but the two coders can be used independently without influencing
other.</p></div>
</dd>
<dt id="constriction.stream.stack.AnsCoder.decode"><code class="name flex">
<span>def <span class="ident">decode</span></span>(<span>self, model, *optional_amt_or_model_params)</span>
</code></dt>
<dd>
<div class="desc"><p>Decodes one or more symbols, consuming them from the encapsulated compressed data.</p>
<p>This method can be called in 3 different ways:</p>
<h2 id="option-1-decodemodel">Option 1: decode(model)</h2>
<p>Decodes a <em>single</em> symbol with a concrete (i.e., fully parameterized) entropy model and
returns the decoded symbol; (for optimal computational efficiency, don't use this option in
a loop if you can instead use one of the two alternative options below.)</p>
<p>For example:</p>
<pre><code class="language-python"># Define a concrete categorical entropy model over the (implied)
# alphabet {0, 1, 2}:
probabilities = np.array([0.1, 0.6, 0.3], dtype=np.float32)
model = constriction.stream.model.Categorical(probabilities, perfect=False)

# Decode a single symbol from some example compressed data:
compressed = np.array([2514924296, 114], dtype=np.uint32)
coder = constriction.stream.stack.AnsCoder(compressed)
symbol = coder.decode(model)
print(symbol) # (prints: 2)
# ... then decode some more symbols ...
</code></pre>
<h2 id="option-2-decodemodel-amt-where-amt-is-an-integer">Option 2: decode(model, amt) [where <code>amt</code> is an integer]</h2>
<p>Decodes <code>amt</code> i.i.d. symbols using the same concrete (i.e., fully parametrized) entropy
model for each symbol, and returns the decoded symbols as a rank-1 numpy array with
<code>dtype=np.int32</code> and length <code>amt</code>;</p>
<p>For example:</p>
<pre><code class="language-python"># Use the same concrete entropy model as in the previous example:
probabilities = np.array([0.1, 0.6, 0.3], dtype=np.float32)
model = constriction.stream.model.Categorical(probabilities, perfect=False)

# Decode 9 symbols from some example compressed data, using the
# same (fixed) entropy model defined above for all symbols:
compressed = np.array([2514924296, 114], dtype=np.uint32)
coder = constriction.stream.stack.AnsCoder(compressed)
symbols = coder.decode(model, 9)
print(symbols) # (prints: [2, 0, 0, 1, 2, 2, 1, 2, 2])
</code></pre>
<h2 id="option-3-decodemodel_family-params1-params2">Option 3: decode(model_family, params1, params2, &hellip;)</h2>
<p>Decodes multiple symbols, using the same <em>family</em> of entropy models (e.g., categorical or
quantized Gaussian) for all symbols, but with different model parameters for each symbol,
and returns the decoded symbols as a rank-1 numpy array with <code>dtype=np.int32</code>; here, all
<code>paramsX</code> arguments are arrays of equal length (the number of symbols to be decoded). The
number of required <code>paramsX</code> arguments and their shapes and <code>dtype</code>s depend on the model
family.</p>
<p>For example, the
<a href="model.html#constriction.stream.model.QuantizedGaussian"><code>QuantizedGaussian</code></a> model family
expects two rank-1 model parameters with float <code>dtype</code>, which specify the mean and
standard deviation for each entropy model:</p>
<pre><code class="language-python"># Define a generic quantized Gaussian distribution for all integers
# in the range from -100 to 100 (both ends inclusive):
model_family = constriction.stream.model.QuantizedGaussian(-100, 100)

# Specify the model parameters for each symbol:
means = np.array([10.3, -4.7, 20.5], dtype=np.float32)
stds  = np.array([ 5.2, 24.2,  3.1], dtype=np.float32)

# Decode a message from some example compressed data:
compressed = np.array([597775281, 3], dtype=np.uint32)
coder = constriction.stream.stack.AnsCoder(compressed)
symbols = coder.decode(model_family, means, stds)
print(symbols) # (prints: [12, -13, 25])
</code></pre>
<p>By contrast, the <a href="model.html#constriction.stream.model.Categorical"><code>Categorical</code></a> model
family expects a single rank-2 model parameter where the i'th row lists the
probabilities for each possible value of the i'th symbol:</p>
<pre><code class="language-python"># Define 2 categorical models over the alphabet {0, 1, 2, 3, 4}:
probabilities = np.array(
    [[0.1, 0.2, 0.3, 0.1, 0.3],  # (for first decoded symbol)
     [0.3, 0.2, 0.2, 0.2, 0.1]], # (for second decoded symbol)
    dtype=np.float32)
model_family = constriction.stream.model.Categorical(perfect=False)

# Decode 2 symbols:
compressed = np.array([2142112014, 31], dtype=np.uint32)
coder = constriction.stream.stack.AnsCoder(compressed)
symbols = coder.decode(model_family, probabilities)
print(symbols) # (prints: [3, 1])
</code></pre></div>
</dd>
<dt id="constriction.stream.stack.AnsCoder.encode_reverse"><code class="name flex">
<span>def <span class="ident">encode_reverse</span></span>(<span>self, symbols, model, *optional_model_params)</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes one or more symbols, appending them to the encapsulated compressed data.</p>
<p>This method can be called in 3 different ways:</p>
<h2 id="option-1-encode_reversesymbol-model">Option 1: encode_reverse(symbol, model)</h2>
<p>Encodes a <em>single</em> symbol with a concrete (i.e., fully parameterized) entropy model; the
suffix "_reverse" of the method name has no significance when called this way.</p>
<p>For optimal computational efficiency, don't use this option in a loop if you can instead
use one of the two alternative options below.</p>
<p>For example:</p>
<pre><code class="language-python"># Define a concrete categorical entropy model over the (implied)
# alphabet {0, 1, 2}:
probabilities = np.array([0.1, 0.6, 0.3], dtype=np.float32)
model = constriction.stream.model.Categorical(probabilities, perfect=False)

# Encode a single symbol with this entropy model:
coder = constriction.stream.stack.AnsCoder()
coder.encode_reverse(2, model) # Encodes the symbol `2`.
# ... then encode some more symbols ...
</code></pre>
<h2 id="option-2-encode_reversesymbols-model">Option 2: encode_reverse(symbols, model)</h2>
<p>Encodes multiple i.i.d. symbols, i.e., all symbols in the rank-1 array <code>symbols</code> will be
encoded with the same concrete (i.e., fully parameterized) entropy model. The symbols are
encoded in <em>reverse</em> order so that subsequent decoding will retrieve them in forward order
(see <a href="#example">module-level example</a>).</p>
<p>For example:</p>
<pre><code class="language-python"># Use the same concrete entropy model as in the previous example:
probabilities = np.array([0.1, 0.6, 0.3], dtype=np.float32)
model = constriction.stream.model.Categorical(probabilities, perfect=False)

# Encode an example message using the above `model` for all symbols:
symbols = np.array([0, 2, 1, 2, 0, 2, 0, 2, 1], dtype=np.int32)
coder = constriction.stream.stack.AnsCoder()
coder.encode_reverse(symbols, model)
print(coder.get_compressed()) # (prints: [1276732052, 172])
</code></pre>
<h2 id="option-3-encode_reversesymbols-model_family-params1-params2">Option 3: encode_reverse(symbols, model_family, params1, params2, &hellip;)</h2>
<p>Encodes multiple symbols, using the same <em>family</em> of entropy models (e.g., categorical or
quantized Gaussian) for all symbols, but with different model parameters for each symbol;
here, each <code>paramsX</code> argument is an array of the same length as <code>symbols</code>. The number of
required <code>paramsX</code> arguments and their shapes and <code>dtype</code>s depend on the model family. The
symbols are encoded in <em>reverse</em> order so that subsequent decoding will retrieve them in
forward order (see <a href="#example">module-level example</a>). But the mapping between symbols and
model parameters is as you'd expect it to be (i.e., <code>symbols[i]</code> gets encoded with model
parameters <code>params1[i]</code>, <code>params2[i]</code>, and so on, where <code>i</code> counts backwards).</p>
<p>For example, the
<a href="model.html#constriction.stream.model.QuantizedGaussian"><code>QuantizedGaussian</code></a> model family
expects two rank-1 model parameters with float <code>dtype</code>, which specify the mean and
standard deviation for each entropy model:</p>
<pre><code class="language-python"># Define a generic quantized Gaussian distribution for all integers
# in the range from -100 to 100 (both ends inclusive):
model_family = constriction.stream.model.QuantizedGaussian(-100, 100)

# Specify the model parameters for each symbol:
means = np.array([10.3, -4.7, 20.5], dtype=np.float32)
stds  = np.array([ 5.2, 24.2,  3.1], dtype=np.float32)

# Encode an example message:
# (needs `len(symbols) == len(means) == len(stds)`)
symbols = np.array([12, -13, 25], dtype=np.int32)
coder = constriction.stream.stack.AnsCoder()
coder.encode_reverse(symbols, model_family, means, stds)
print(coder.get_compressed()) # (prints: [597775281, 3])
</code></pre>
<p>By contrast, the <a href="model.html#constriction.stream.model.Categorical"><code>Categorical</code></a> model
family expects a single rank-2 model parameter where the i'th row lists the
probabilities for each possible value of the i'th symbol:</p>
<pre><code class="language-python"># Define 2 categorical models over the alphabet {0, 1, 2, 3, 4}:
probabilities = np.array(
    [[0.1, 0.2, 0.3, 0.1, 0.3],  # (for symbols[0])
     [0.3, 0.2, 0.2, 0.2, 0.1]], # (for symbols[1])
    dtype=np.float32)
model_family = constriction.stream.model.Categorical(perfect=False)

# Encode 2 symbols (needs `len(symbols) == probabilities.shape[0]`):
symbols = np.array([3, 1], dtype=np.int32)
coder = constriction.stream.stack.AnsCoder()
coder.encode_reverse(symbols, model_family, probabilities)
print(coder.get_compressed()) # (prints: [45298482])
</code></pre></div>
</dd>
<dt id="constriction.stream.stack.AnsCoder.get_compressed"><code class="name flex">
<span>def <span class="ident">get_compressed</span></span>(<span>self, unseal=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of the compressed data.</p>
<p>You'll almost always want to call this method without arguments (which will default to
<code>unseal=False</code>). See below for an explanation of the advanced use case with argument
<code>unseal=True</code>.</p>
<p>You will typically only want to call this method at the very end of your encoding task,
i.e., once you've encoded the <em>entire</em> message. There is usually no need to call this method
after encoding each symbol or other portion of your message. The encoders in <code><a title="constriction" href="../index.html">constriction</a></code>
<em>accumulate</em> compressed data in an internal buffer, and encoding (semantically) <em>appends</em> to
this buffer.</p>
<p>That said, calling <code>get_compressed</code> has no side effects, so you <em>can</em> call <code>get_compressed</code>,
then continue to encode more symbols, and then call <code>get_compressed</code> again. The first call
of <code>get_compressed</code> will have no effect on the return value of the second call of
<code>get_compressed</code>.</p>
<p>The return value is a rank-1 numpy array of <code>dtype=np.uint32</code>. You can write it to a file by
calling <code>to_file</code> on it, but we recommend to convert it into an architecture-independent
byte order first:</p>
<pre><code class="language-python">import sys

encoder = constriction.stream.stack.AnsCoder()
# ... encode some message (skipped here) ...
compressed = encoder.get_compressed() # returns a numpy array.
if sys.byteorder != 'little':
    # Let's save data in little-endian byte order by convention.
    compressed.byteswap(inplace=True)
compressed.tofile('compressed-file.bin')

# At a later point, you might want to read and decode the file:
compressed = np.fromfile('compressed-file.bin', dtype=np.uint32)
if sys.byteorder != 'little':
    # Restore native byte order before passing it to `constriction`.
    compressed.byteswap(inplace=True)
decoder = constriction.stream.stack.AnsCoder(compressed)
# ... decode the message (skipped here) ...
</code></pre>
<h2 id="explanation-of-the-optional-argument-unseal">Explanation of the optional argument <code>unseal</code></h2>
<p>The optional argument <code>unseal</code> of this method is the counterpart to the optional argument
<code>seal</code> of the constructor. Calling <code>.get_compressed(unseal=True)</code> tells the ANS coder that
you expect it to be in a "sealed" state and instructs it to reverse the "sealing" operation.
An ANS coder is in a sealed state if its encapsulated compressed data ends in a single "1"
word. Calling the constructor of <code><a title="constriction.stream.stack.AnsCoder" href="#constriction.stream.stack.AnsCoder">AnsCoder</a></code> with argument <code>seal=True</code> constructs a coder
that is guaranteed to be in a sealed state because the constructor will append a single "1"
word to the provided <code>compressed</code> data. This sealing/unsealing operation makes sure that any
trailing zero words are conserved since an <code><a title="constriction.stream.stack.AnsCoder" href="#constriction.stream.stack.AnsCoder">AnsCoder</a></code> would otherwise truncate them.</p>
<p>Note that calling <code>.get_compressed(unseal=True)</code> fails if the coder is not in a "sealed"
state.</p></div>
</dd>
<dt id="constriction.stream.stack.AnsCoder.is_empty"><code class="name flex">
<span>def <span class="ident">is_empty</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns <code>True</code> iff the coder is in its default initial state.</p>
<p>The default initial state is the state returned by the constructor when
called without arguments, or the state to which the coder is set when
calling <code>clear</code>.</p></div>
</dd>
<dt id="constriction.stream.stack.AnsCoder.num_bits"><code class="name flex">
<span>def <span class="ident">num_bits</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current size of the compressed data, in bits, rounded up to full words.</p>
<p>This is 32 times the result of what <a href="#constriction.stream.queue.RangeEncoder.num_words"><code>num_words</code></a>
would return.</p></div>
</dd>
<dt id="constriction.stream.stack.AnsCoder.num_valid_bits"><code class="name flex">
<span>def <span class="ident">num_valid_bits</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The current size of the compressed data, in bits, not rounded up to full words.</p>
<p>This can be at most 32 smaller than <code>.num_bits()</code>.</p></div>
</dd>
<dt id="constriction.stream.stack.AnsCoder.num_words"><code class="name flex">
<span>def <span class="ident">num_words</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current size of the encapsulated compressed data, in <code>np.uint32</code> words.</p>
<p>Thus, the number returned by this method is the length of the array that you would get if
you called <a href="#constriction.stream.queue.RangeEncoder.get_compressed"><code>get_compressed</code></a>
without arguments.</p></div>
</dd>
<dt id="constriction.stream.stack.AnsCoder.pos"><code class="name flex">
<span>def <span class="ident">pos</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Records a checkpoint to which you can jump during decoding using
<a href="#constriction.stream.stack.AnsCoder.seek"><code>seek</code></a>.</p>
<p>Returns a tuple <code>(position, state)</code> where <code>position</code> is an integer that specifies how many
32-bit words of compressed data have been produced so far, and <code>state</code> is an integer that
defines the <code>RangeEncoder</code>'s internal state (so that it can be restored upon
<a href="#constriction.stream.stack.AnsCoder.seek"><code>seek</code>ing</a>.</p>
<p><strong>Note:</strong> Don't call <code>pos</code> if you just want to find out how much compressed data has been
produced so far. Call <a href="#constriction.stream.stack.AnsCoder.num_words"><code>num_words</code></a>
instead.</p>
<h2 id="example">Example</h2>
<p>See <a href="#constriction.stream.stack.AnsCoder.seek"><code>seek</code></a>.</p></div>
</dd>
<dt id="constriction.stream.stack.AnsCoder.seek"><code class="name flex">
<span>def <span class="ident">seek</span></span>(<span>self, position, state)</span>
</code></dt>
<dd>
<div class="desc"><p>Jumps to a checkpoint recorded with method
<a href="#constriction.stream.stack.AnsCoder.pos"><code>pos</code></a> during encoding.</p>
<p>This allows random-access decoding. The arguments <code>position</code> and <code>state</code> are the two values
returned by the method [<code>pos</code>](#constriction.stream.stack</p>
<p><strong>Note:</strong> in an ANS coder, both decoding and seeking <em>consume</em> compressed data. The Python
API of <code><a title="constriction" href="../index.html">constriction</a></code>'s ANS coder currently supports only seeking forward but not backward
(seeking backward is supported for Range Coding, and for both ANS and Range Coding in
<code><a title="constriction" href="../index.html">constriction</a></code>'s Rust API).</p>
<h2 id="example">Example</h2>
<pre><code class="language-python">probabilities = np.array([0.2, 0.4, 0.1, 0.3], dtype=np.float32)
model         = constriction.stream.model.Categorical(probabilities, perfect=False)
message_part1 = np.array([1, 2, 0, 3, 2, 3, 0], dtype=np.int32)
message_part2 = np.array([2, 2, 0, 1, 3], dtype=np.int32)

# Encode both parts of the message (in reverse order, because ANS
# operates as a stack) and record a checkpoint in-between:
coder = constriction.stream.stack.AnsCoder()
coder.encode_reverse(message_part2, model)
(position, state) = coder.pos() # Records a checkpoint.
coder.encode_reverse(message_part1, model)

# We could now call `coder.get_compressed()` but we'll just decode
# directly from the original `coder` for simplicity.

# Decode first symbol:
print(coder.decode(model)) # (prints: 1)

# Jump to part 2 and decode it:
coder.seek(position, state)
decoded_part2 = coder.decode(model, 5)
assert np.all(decoded_part2 == message_part2)
</code></pre></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul>
<li><a href="#stack-semantics">Stack Semantics</a></li>
<li><a href="#example">Example</a></li>
<li><a href="#references">References</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="constriction.stream" href="../stream.html">constriction.stream</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="constriction.stream.stack.AnsCoder" href="#constriction.stream.stack.AnsCoder">AnsCoder</a></code></h4>
<ul class="two-column">
<li><code><a title="constriction.stream.stack.AnsCoder.clear" href="#constriction.stream.stack.AnsCoder.clear">clear</a></code></li>
<li><code><a title="constriction.stream.stack.AnsCoder.clone" href="#constriction.stream.stack.AnsCoder.clone">clone</a></code></li>
<li><code><a title="constriction.stream.stack.AnsCoder.decode" href="#constriction.stream.stack.AnsCoder.decode">decode</a></code></li>
<li><code><a title="constriction.stream.stack.AnsCoder.encode_reverse" href="#constriction.stream.stack.AnsCoder.encode_reverse">encode_reverse</a></code></li>
<li><code><a title="constriction.stream.stack.AnsCoder.get_compressed" href="#constriction.stream.stack.AnsCoder.get_compressed">get_compressed</a></code></li>
<li><code><a title="constriction.stream.stack.AnsCoder.is_empty" href="#constriction.stream.stack.AnsCoder.is_empty">is_empty</a></code></li>
<li><code><a title="constriction.stream.stack.AnsCoder.num_bits" href="#constriction.stream.stack.AnsCoder.num_bits">num_bits</a></code></li>
<li><code><a title="constriction.stream.stack.AnsCoder.num_valid_bits" href="#constriction.stream.stack.AnsCoder.num_valid_bits">num_valid_bits</a></code></li>
<li><code><a title="constriction.stream.stack.AnsCoder.num_words" href="#constriction.stream.stack.AnsCoder.num_words">num_words</a></code></li>
<li><code><a title="constriction.stream.stack.AnsCoder.pos" href="#constriction.stream.stack.AnsCoder.pos">pos</a></code></li>
<li><code><a title="constriction.stream.stack.AnsCoder.seek" href="#constriction.stream.stack.AnsCoder.seek">seek</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
